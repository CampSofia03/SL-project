library(tidyverse)
install.packages("ggplot2")
library(ggplot2)
install.packages("psych")
library(psych)
library(knitr)
installed.packages()["factoextra", ]
library(factoextra)
install.packages("dplyr")
library(dplyr)

#Data Preparation 

file_path <- file.choose()
data <- read.csv(file_path)
data%>%head()
table(data$gender)
table(data$race.ethnicity)
table(data$parental.level.of.education)
table(data$lunch)

summary(data) # Visualizza i valori


#Data Cleaning 

sum(is.na(data))  # Conta il numero totale di NA nel dataset
colSums(is.na(data))  # Conta gli NA per ogni colonna
data[!complete.cases(data), ]  # Visualizza le righe con NA
sum(duplicated(data)) # Visualizza i valori duplicati
lapply(data[, sapply(data, is.character)], unique) #Verificare i valori unici nelle colonne categoriche



#Analysis of Lunch
totalLunch <- table(data$lunch)
totalLunch


# Raggruppamento per tipo di pranzo e calcolo dei punteggi totali
lunch_summary <- data %>% 
  group_by(lunch) %>%
  summarise(
    mathTotal = sum(math.score, na.rm = TRUE),
    readingTotal = sum(reading.score, na.rm = TRUE),
    writingTotal = sum(writing.score, na.rm = TRUE)
  ) %>%
  mutate(totalScores = mathTotal + readingTotal + writingTotal)

# Creazione del grafico con miglioramenti estetici
ggplot(lunch_summary, aes(x = lunch, y = totalScores, fill = lunch)) + 
  geom_bar(stat = "identity", width = 0.6) +  # Ridotto leggermente la larghezza delle barre
  labs(
    title = "Test Preparation Comparison",
    subtitle = "Total Scores by Lunch Type",
    x = "Lunch Type",
    y = "Total Scores"
  ) +
  theme_minimal() +  # Tema più pulito
  theme(
    axis.text.x = element_text(vjust = 1, hjust = 0.5),  # Migliore leggibilità etichette asse X
    legend.position = "none"  # Nasconde la legenda se il fill corrisponde all'asse X
  ) +
  geom_text(aes(label = totalScores), vjust = -0.5, size = 3)  # Aggiunti numeri sopra le barre

TOGLI!!!!
#names(data)[names(data) == "gender"] <- "Gender"
#names(data)[names(data) == "race.ethnicity"] <- "Race Ethnicity"
#names(data)[names(data) == "parental.level.of.education"] <- "Parental Level of Education"
#names(data)[names(data) == "test.preparation.course"] <- "Test Preparation Course"
#names(data)[names(data) == "math.score"] <- "Math Score"
#names(data)[names(data) == "lunch"] <- "Lunch"
#names(data)[names(data) == "reading.score"] <- "Reading Score"
#names(data)[names(data) == "writing.score"] <- "Writing Score"


#Data Distribution Overview

kable(head(data, 5)) #head(data, 5)

#Analysis of Ethnicity
x1 <- data %>% 
  group_by(race.ethnicity) %>%
  filter(math.score > 80, writing.score > 80, reading.score > 80) 
table(x1$race.ethnicity)
x1 %>% ggplot() + geom_bar(aes(x1$race.ethnicity,fill = x1$race.ethnicity))

# Istogramma per Math Score
ggplot(data, aes(x = `Math Score`)) +
  geom_histogram(bins = 20, fill = "skyblue", color = "black") +
  ggtitle("Distribuzione dei Punteggi di Matematica") +
  xlab("Math Score") +
  ylab("Frequenza")

# Istogramma per Reading Score
ggplot(data, aes(x = `Reading Score`)) +
  geom_histogram(bins = 20, fill = "lightgreen", color = "black") +
  ggtitle("Distribuzione dei Punteggi di Lettura") +
  xlab("Reading Score") +
  ylab("Frequenza")

# Istogramma per Writing Score
ggplot(data, aes(x = `Writing Score`)) +
  geom_histogram(bins = 20, fill = "salmon", color = "black") +
  ggtitle("Distribuzione dei Punteggi di Scrittura") +
  xlab("Writing Score") +
  ylab("Frequenza")



#Outlier Elimination Strategy

numeric_cols <- c("Math Score", "Reading Score", "Writing Score") #colonne numeriche

for (col in numeric_cols) {
  Q1 <- quantile(data[[col]], 0.25, na.rm = TRUE)
  Q3 <- quantile(data[[col]], 0.75, na.rm = TRUE)
  IQR_value <- Q3 - Q1
  
  # Visualizza i limiti per il debug
  cat("\nColonna:", col, "\nQ1:", Q1, "\nQ3:", Q3, "\nIQR:", IQR_value, "\n")
  
  # Controlla il numero di righe prima e dopo il filtro
  cat("Righe prima:", nrow(data), "\n")
  
  data <- data[data[[col]] >= (Q1 - 1.5 * IQR_value) & 
                 data[[col]] <= (Q3 + 1.5 * IQR_value), ]
  
  cat("Righe dopo:", nrow(data), "\n")
}

summary(data)


#Clustering, Visualization, Comparison

data_scaled <- scale(data[, numeric_cols])

installed.packages()["factoextra", ]
library(factoextra)
data_scaled <- scale(data[, numeric_cols])

# Determinazione del numero ottimale di cluster con il metodo "Elbow"
set.seed(123)  # Per garantire la riproducibilità
fviz_nbclust(data_scaled, kmeans, method = "wss") +
  geom_vline(xintercept = 4, linetype = 2) +
  labs(subtitle = "Metodo del Gomito (Elbow Method)")

# Esecuzione del clustering K-means
k <- 5  # Numero di cluster scelto
set.seed(123)
km_result <- kmeans(data_scaled, centers = k, nstart = 25)
# Aggiunta del cluster ai dati originali
data$Cluster <- as.factor(km_result$cluster)
fviz_cluster(km_result, data = data_scaled, 
             geom = "point", ellipse.type = "norm",
             palette = "jco", ggtheme = theme_minimal())

head(data)

#Reading, Writing, Maths plot

girl_data<-data%>%filter(gender=='female')
boy_data<-data%>%filter(gender=='male')
ggplot()+
  geom_point(girl_data,mapping=aes(`math.score`,`reading.score`,color='female'))+
  geom_point(boy_data,mapping=aes(`math.score`,`reading.score`,color='male'))+labs(title='Math and Reading Score')
ggplot()+
  geom_point(girl_data,mapping=aes(`math.score`,`writing.score`,color='female'))+
  geom_point(boy_data,mapping = aes(`math.score`,`writing.score`,color='male'))+labs(title='Math and Writing Score')
ggplot()+
  geom_point(girl_data,mapping=aes(`reading.score`,`writing.score`,color='female'))+
  geom_point(boy_data,mapping = aes(`reading.score`,`writing.score`,color='male'))+labs(title='Reading and Writing Score')

pairs.panels(data[, 6:8],
             method = "pearson",  # Metodo di correlazione (Pearson di default)
             hist.col = "skyblue", # Colore degli istogrammi
             density = TRUE,       # Aggiunge curve di densità
             ellipses = TRUE,      # Aggiunge ellissi di correlazione
             lm = TRUE             # Aggiunge linee di regressione lineare
)


#Central Point

# Calcolo della media per Math Score e Reading Score
central_math_score <- mean(data$`math.score`, na.rm = TRUE)
central_reading_score <- mean(data$`reading.score`, na.rm = TRUE)
central_writing_score <- mean(data$`writing.score`, na.rm = TRUE)

# Visualizzazione dei risultati
cat("Punto centrale (Math Score):", central_math_score, "\n")
cat("Punto centrale (Reading Score):", central_reading_score, "\n")
cat("Punto centrale (Writing Score):", central_writing_score, "\n")


# Calcolo della media per Math Score e Reading Score suddiviso per genere

mean_scores <- data %>%
  group_by(gender) %>%
  summarise(
    math_mean = mean(math.score, na.rm = TRUE),
    writing_mean = mean(writing.score, na.rm = TRUE),
    reading_mean = mean(reading.score, na.rm = TRUE)
  ) %>%
  pivot_longer(cols = c(math_mean, writing_mean, reading_mean), 
               names_to = "subject", 
               values_to = "mean_score")

# Creazione del grafico con valori numerici sopra le barre
ggplot(mean_scores, aes(x = gender, y = mean_score, fill = subject)) +
  geom_bar(stat = "identity", position = "dodge") +
  geom_text(aes(label = round(mean_score, 1)), 
            position = position_dodge(width = 0.9), 
            vjust = -0.5, size = 3) +
  labs(title = "Media dei punteggi per genere",
       x = "Genere",
       y = "Media del punteggio",
       fill = "Materia") +
  theme_minimal()


#Categorical Column Mean
# Calcolo del punteggio medio per ciascun gruppo etnico

data %>%
  group_by(`gender`) %>%
  summarize(avg_score = round(mean(`math.score` + `reading.score` + `writing.score`) / 3, 1)) %>%
  ggplot(aes(x = `gender`, y = avg_score, fill = `gender`)) +
  geom_bar(stat = 'identity') +
  geom_text(aes(label = avg_score), vjust = -0.3, size = 4) +  # Etichette sopra le barre
  coord_flip() +  # Ruota il grafico orizzontalmente
  labs(title = 'Average Score of Each Gender', x = 'Race/Ethnicity', y = 'Average Score') +
  guides(fill = "none") +  # Rimuove la legenda
  theme_minimal()
data %>%
  group_by(`race.ethnicity`) %>%
  summarize(avg_score = round(mean(`math.score` + `reading.score` + `writing.score`) / 3, 1)) %>%
  ggplot(aes(x = `race.ethnicity`, y = avg_score, fill = `race.ethnicity`)) +
  geom_bar(stat = 'identity') +
  geom_text(aes(label = avg_score), vjust = -0.3, size = 4) +  # Etichette sopra le barre
  coord_flip() +  # Ruota il grafico orizzontalmente
  labs(title = 'Average Score of Each Race Ethnicity', x = 'Race/Ethnicity', y = 'Average Score') +
  guides(fill = "none") +  # Rimuove la legenda
  theme_minimal()

--> Parental level of Education |     Lunch     |   Test Preparation Course




#Central Point


# Funzione per calcolare la distanza euclidea dal punto centrale
euclidean_distance <- function(math, reading, writing) {
  sqrt((math - central_math_score)^2 +
         (reading - central_reading_score)^2 +
         (writing - central_writing_score)^2)
}
  
# Calcolo della distanza per ciascuna riga del dataset
data$DistanceFromCenter <- mapply(euclidean_distance,
                                  math = data$`math.score`,
                                  reading = data$`reading.score`,
                                  writing = data$`writing.score`)

# Visualizzazione dei primi risultati
head(data)

# Creazione di un sottoinsieme con i primi 6 esempi
subset_data <- data[1:6, ]

# Definizione del punto centrale
central_point <- data.frame(
  `math.score` = central_math_score,
  `reading.score` = central_reading_score,
  `writing.ccore` = central_writing_score
)

# Grafico a dispersione
ggplot(subset_data, aes(x = `math.score`, y = `reading.score`, color = as.factor(Cluster))) +
  geom_point(size = 4, alpha = 0.8) +  # Punti per ogni esempio
  geom_point(data = central_point, aes(x = `math.score`, y = `reading.score`),
             color = "black", size = 6, shape = 4, stroke = 2) +  # Punto centrale (simbolo a croce)
  geom_text(aes(label = round(DistanceFromCenter, 2)), vjust = -1, size = 3) +  # Etichette arrotondate a 2 decimali
  scale_color_brewer(palette = "Set2", name = "Cluster") +  # Colorazione per cluster
  labs(title = "Distribuzione degli Esempi con Punto Centrale",
       x = "Math Score", y = "Reading Score") +
  theme_minimal() +
  theme(legend.position = "right")

# Parental Level of education vs ethnicity

data %>%
  group_by(`race.ethnicity`, `parental.level.of.education`) %>%
  summarize(count = n(), .groups = "drop") %>%  # .groups = "drop" per evitare messaggi di warning
  ggplot(aes(x = `race.ethnicity`, y = count, fill = `parental.level.of.education`)) +
  geom_col(position = "dodge") +
  scale_fill_manual(values = c("#006400", "#008000", "#32CD32", "#66CDAA", "#00FA9A", "#7FFF00")) +  # Tonalità di verde
  labs(title = "Distribuzione del Livello di Istruzione dei Genitori per Etnia",
       x = "Etnia",
       y = "Numero di Studenti",
       fill = "Livello di Istruzione") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Ruota le etichette per leggibilità

# BoxPlot representing the math score for those who completed or not the test preparation divided by group etinicity
# Creazione dei sottoinsiemi per ogni gruppo etnico
groupa <- data %>% filter(`race.ethnicity` == "group A")
groupb <- data %>% filter(`race.ethnicity` == "group B")
groupc <- data %>% filter(`race.ethnicity` == "group C")
groupd <- data %>% filter(`race.ethnicity` == "group D")
groupe <- data %>% filter(`race.ethnicity` == "group E")

# Funzione per generare i boxplot per ciascun gruppo
create_boxplot <- function(data, group_name) {
  ggplot(data, aes(x = reorder(`test.preparation.course`, math.score, median), y = math.score)) +
    geom_boxplot(fill = "lightblue", color = "black") +
    ggtitle(paste("GROUP", group_name)) +
    xlab("Test Preparation Course") +
    ylab("Math Score") +
    coord_flip() +
    theme_minimal()
}

# Genera i boxplot per ogni gruppo etnico
create_boxplot(groupa, "A")
create_boxplot(groupb, "B")
create_boxplot(groupc, "C")
create_boxplot(groupd, "D")
create_boxplot(groupe, "E")


#Correlation of scores

# Calcolo della matrice di correlazione e dei p-value
res2 <- rcorr(as.matrix(data[, c("math.score", "writing.score", "reading.score")]))

# Funzione per appiattire la matrice di correlazione in formato tabella
flattenCorrMatrix <- function(cormat, pmat) {
  ut <- upper.tri(cormat)  # Seleziona solo la parte superiore della matrice
  data.frame(
    Variable1 = rownames(cormat)[row(cormat)[ut]],
    Variable2 = colnames(cormat)[col(cormat)[ut]],
    Correlation = round(cormat[ut], 3),  # Arrotonda le correlazioni a 3 decimali
    P_value = round(pmat[ut], 4)  # Arrotonda i p-value a 4 decimali
  )
}

# Creazione della tabella delle correlazioni
cor_table <- flattenCorrMatrix(res2$r, res2$P)

# Stampa la tabella
print(cor_table)




library(tidyverse)
install.packages("ggplot2")
library(ggplot2)
install.packages("psych")
library(psych)
library(knitr)
installed.packages()["factoextra", ]
library(factoextra)
install.packages("dplyr")
library(dplyr)

#Data Preparation 

file_path <- file.choose()
data <- read.csv(file_path)
data%>%head()
table(data$gender)
table(data$race.ethnicity)
table(data$parental.level.of.education)
table(data$lunch)

summary(data) # Visualizza i valori


#Data Cleaning 

sum(is.na(data))  # Conta il numero totale di NA nel dataset
colSums(is.na(data))  # Conta gli NA per ogni colonna
data[!complete.cases(data), ]  # Visualizza le righe con NA
sum(duplicated(data)) # Visualizza i valori duplicati
lapply(data[, sapply(data, is.character)], unique) #Verificare i valori unici nelle colonne categoriche

TOGLI!!!!
names(data)[names(data) == "gender"] <- "Gender"
names(data)[names(data) == "race.ethnicity"] <- "Race Ethnicity"
names(data)[names(data) == "parental.level.of.education"] <- "Parental Level of Education"
names(data)[names(data) == "test.preparation.course"] <- "Test Preparation Course"
names(data)[names(data) == "math.score"] <- "Math Score"
names(data)[names(data) == "lunch"] <- "Lunch"
names(data)[names(data) == "reading.score"] <- "Reading Score"
names(data)[names(data) == "writing.score"] <- "Writing Score"


#Data Distribution Overview

kable(head(data, 5)) #head(data, 5)


# Istogramma per Math Score
ggplot(data, aes(x = `Math Score`)) +
  geom_histogram(bins = 20, fill = "skyblue", color = "black") +
  ggtitle("Distribuzione dei Punteggi di Matematica") +
  xlab("Math Score") +
  ylab("Frequenza")

# Istogramma per Reading Score
ggplot(data, aes(x = `Reading Score`)) +
  geom_histogram(bins = 20, fill = "lightgreen", color = "black") +
  ggtitle("Distribuzione dei Punteggi di Lettura") +
  xlab("Reading Score") +
  ylab("Frequenza")

# Istogramma per Writing Score
ggplot(data, aes(x = `Writing Score`)) +
  geom_histogram(bins = 20, fill = "salmon", color = "black") +
  ggtitle("Distribuzione dei Punteggi di Scrittura") +
  xlab("Writing Score") +
  ylab("Frequenza")



#Outlier Elimination Strategy

numeric_cols <- c("Math Score", "Reading Score", "Writing Score") #colonne numeriche

for (col in numeric_cols) {
  Q1 <- quantile(data[[col]], 0.25, na.rm = TRUE)
  Q3 <- quantile(data[[col]], 0.75, na.rm = TRUE)
  IQR_value <- Q3 - Q1
  
  # Visualizza i limiti per il debug
  cat("\nColonna:", col, "\nQ1:", Q1, "\nQ3:", Q3, "\nIQR:", IQR_value, "\n")
  
  # Controlla il numero di righe prima e dopo il filtro
  cat("Righe prima:", nrow(data), "\n")
  
  data <- data[data[[col]] >= (Q1 - 1.5 * IQR_value) & 
                 data[[col]] <= (Q3 + 1.5 * IQR_value), ]
  
  cat("Righe dopo:", nrow(data), "\n")
}

summary(data)


#Clustering, Visualization, Comparison

data_scaled <- scale(data[, numeric_cols])

installed.packages()["factoextra", ]
library(factoextra)
data_scaled <- scale(data[, numeric_cols])

# Determinazione del numero ottimale di cluster con il metodo "Elbow"
set.seed(123)  # Per garantire la riproducibilità
fviz_nbclust(data_scaled, kmeans, method = "wss") +
  geom_vline(xintercept = 4, linetype = 2) +
  labs(subtitle = "Metodo del Gomito (Elbow Method)")

# Esecuzione del clustering K-means
k <- 5  # Numero di cluster scelto
set.seed(123)
km_result <- kmeans(data_scaled, centers = k, nstart = 25)
# Aggiunta del cluster ai dati originali
data$Cluster <- as.factor(km_result$cluster)
fviz_cluster(km_result, data = data_scaled, 
             geom = "point", ellipse.type = "norm",
             palette = "jco", ggtheme = theme_minimal())

head(data)

#Reading, Writing, Maths plot

girl_data<-data%>%filter(gender=='female')
boy_data<-data%>%filter(gender=='male')
ggplot()+
  geom_point(girl_data,mapping=aes(`math.score`,`reading.score`,color='female'))+
  geom_point(boy_data,mapping=aes(`math.score`,`reading.score`,color='male'))+labs(title='Math and Reading Score')
ggplot()+
  geom_point(girl_data,mapping=aes(`math.score`,`writing.score`,color='female'))+
  geom_point(boy_data,mapping = aes(`math.score`,`writing.score`,color='male'))+labs(title='Math and Writing Score')
ggplot()+
  geom_point(girl_data,mapping=aes(`reading.score`,`writing.score`,color='female'))+
  geom_point(boy_data,mapping = aes(`reading.score`,`writing.score`,color='male'))+labs(title='Reading and Writing Score')

pairs.panels(data[, 6:8],
             method = "pearson",  # Metodo di correlazione (Pearson di default)
             hist.col = "skyblue", # Colore degli istogrammi
             density = TRUE,       # Aggiunge curve di densità
             ellipses = TRUE,      # Aggiunge ellissi di correlazione
             lm = TRUE             # Aggiunge linee di regressione lineare
)


#Central Point

# Calcolo della media per Math Score e Reading Score
central_math_score <- mean(data$`math.score`, na.rm = TRUE)
central_reading_score <- mean(data$`reading.score`, na.rm = TRUE)
central_writing_score <- mean(data$`writing.score`, na.rm = TRUE)

# Visualizzazione dei risultati
cat("Punto centrale (Math Score):", central_math_score, "\n")
cat("Punto centrale (Reading Score):", central_reading_score, "\n")
cat("Punto centrale (Writing Score):", central_writing_score, "\n")

#Categorical Column Mean
# Calcolo del punteggio medio per ciascun gruppo etnico

data %>%
  group_by(`gender`) %>%
  summarize(avg_score = round(mean(`math.score` + `reading.score` + `writing.score`) / 3, 1)) %>%
  ggplot(aes(x = `gender`, y = avg_score, fill = `gender`)) +
  geom_bar(stat = 'identity') +
  geom_text(aes(label = avg_score), vjust = -0.3, size = 4) +  # Etichette sopra le barre
  coord_flip() +  # Ruota il grafico orizzontalmente
  labs(title = 'Average Score of Each Gender', x = 'Race/Ethnicity', y = 'Average Score') +
  guides(fill = "none") +  # Rimuove la legenda
  theme_minimal()
data %>%
  group_by(`race.ethnicity`) %>%
  summarize(avg_score = round(mean(`math.score` + `reading.score` + `writing.score`) / 3, 1)) %>%
  ggplot(aes(x = `race.ethnicity`, y = avg_score, fill = `race.ethnicity`)) +
  geom_bar(stat = 'identity') +
  geom_text(aes(label = avg_score), vjust = -0.3, size = 4) +  # Etichette sopra le barre
  coord_flip() +  # Ruota il grafico orizzontalmente
  labs(title = 'Average Score of Each Race Ethnicity', x = 'Race/Ethnicity', y = 'Average Score') +
  guides(fill = "none") +  # Rimuove la legenda
  theme_minimal()

--> Parental level of Education |     Lunch     |   Test Preparation Course




#Central Point


# Funzione per calcolare la distanza euclidea dal punto centrale
euclidean_distance <- function(math, reading, writing) {
  sqrt((math - central_math_score)^2 +
         (reading - central_reading_score)^2 +
         (writing - central_writing_score)^2)
}
  
# Calcolo della distanza per ciascuna riga del dataset
data$DistanceFromCenter <- mapply(euclidean_distance,
                                  math = data$`math.score`,
                                  reading = data$`reading.score`,
                                  writing = data$`writing.score`)

# Visualizzazione dei primi risultati
head(data)

# Creazione di un sottoinsieme con i primi 6 esempi
subset_data <- data[1:6, ]

# Definizione del punto centrale
central_point <- data.frame(
  `math.score` = central_math_score,
  `reading.score` = central_reading_score,
  `writing.ccore` = central_writing_score
)

# Grafico a dispersione
ggplot(subset_data, aes(x = `math.score`, y = `reading.score`, color = as.factor(Cluster))) +
  geom_point(size = 4, alpha = 0.8) +  # Punti per ogni esempio
  geom_point(data = central_point, aes(x = `math.score`, y = `reading.score`),
             color = "black", size = 6, shape = 4, stroke = 2) +  # Punto centrale (simbolo a croce)
  geom_text(aes(label = round(DistanceFromCenter, 2)), vjust = -1, size = 3) +  # Etichette arrotondate a 2 decimali
  scale_color_brewer(palette = "Set2", name = "Cluster") +  # Colorazione per cluster
  labs(title = "Distribuzione degli Esempi con Punto Centrale",
       x = "Math Score", y = "Reading Score") +
  theme_minimal() +
  theme(legend.position = "right")

# Parental Level of education vs ethnicity

data %>%
  group_by(`race.ethnicity`, `parental.level.of.education`) %>%
  summarize(count = n(), .groups = "drop") %>%  # .groups = "drop" per evitare messaggi di warning
  ggplot(aes(x = `race.ethnicity`, y = count, fill = `parental.level.of.education`)) +
  geom_col(position = "dodge") +
  scale_fill_manual(values = c("#006400", "#008000", "#32CD32", "#66CDAA", "#00FA9A", "#7FFF00")) +  # Tonalità di verde
  labs(title = "Distribuzione del Livello di Istruzione dei Genitori per Etnia",
       x = "Etnia",
       y = "Numero di Studenti",
       fill = "Livello di Istruzione") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Ruota le etichette per leggibilità

# BoxPlot representing the math score for those who completed or not the test preparation divided by group etinicity
# Creazione dei sottoinsiemi per ogni gruppo etnico
groupa <- data %>% filter(`race.ethnicity` == "group A")
groupb <- data %>% filter(`race.ethnicity` == "group B")
groupc <- data %>% filter(`race.ethnicity` == "group C")
groupd <- data %>% filter(`race.ethnicity` == "group D")
groupe <- data %>% filter(`race.ethnicity` == "group E")

# Funzione per generare i boxplot per ciascun gruppo
create_boxplot <- function(data, group_name) {
  ggplot(data, aes(x = reorder(`test.preparation.course`, math.score, median), y = math.score)) +
    geom_boxplot(fill = "lightblue", color = "black") +
    ggtitle(paste("GROUP", group_name)) +
    xlab("Test Preparation Course") +
    ylab("Math Score") +
    coord_flip() +
    theme_minimal()
}

# Genera i boxplot per ogni gruppo etnico
create_boxplot(groupa, "A")
create_boxplot(groupb, "B")
create_boxplot(groupc, "C")
create_boxplot(groupd, "D")
create_boxplot(groupe, "E")
